[
	{
		"name":"单一职责原则",
		"what":"\u3000\u3000Single Responsibility Principle ，就一个类而言，应该仅有一个引起变化的原因。",
		"how":"\u3000\u3000遵守单一职责原则，将不同的职责封装到不同的类或模块中。",
		"why":"\u3000\u3000如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。",
		"example":"",
		"url":""
	},
	{
		"name":"开闭原则",
		"what":"\u3000\u3000Open Close Principle，软件中的对象（类、模块、函数等）应该对于扩展是开放的，对于修改是封闭的。",
		"how":"\u3000\u3000实现开闭原则的关键就在于“抽象”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。",
		"why":"\u3000\u3000可复用性好。\n\u3000\u3000我们可以在软件完成以后，仍然可以对软件进行扩展，加入新的功能，非常灵活。因此，这个软件系统就可以通过不断地增加新的组件，来满足不断变化的需求。\n\u3000\u3000可维护性好。\n\u3000\u3000由于对于已有的软件系统的组件，特别是它的抽象底层不去修改，因此，我们不用担心软件系统中原有组件的稳定性，这就使变化中的软件系统有一定的稳定性和延续性。",
		"example":"",
		"url":""
	},
	{
		"name":"里氏替换原则",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"依赖倒置原则",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"接口隔离原则",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"迪米特原则",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"单例模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"Builder模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"原型模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"工厂方法模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"抽象工厂模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"策略模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"状态模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"责任链模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"解释器模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"命令模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"观察模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"备忘录模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"迭代器模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"模板方法模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"访问者模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"中介者模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"代理模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"组合模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"适配器模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"装饰模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"享元模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"外观模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"桥接模式",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"mvc",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"mvp",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	},
	{
		"name":"mvvm",
		"what":"",
		"how":"",
		"why":"",
		"example":"",
		"url":""
	}
]
